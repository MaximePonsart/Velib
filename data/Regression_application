

#prerequis: avoir les 2 tables 
#stations-velib-disponibilites-en-temps-reel.csv
#data_all_Paris.jjson.txt

#PROJET MONUMENTalVELIB
#Participants: Laurent Camus - Severine Castor - Sunil Pavitrin - Maxime Ponsart
#V1: atelier R 31/01
#humeur des participants: 
#

#installation des packages
install.packages("jsonlite")
install.packages("lubridate")
install.packages("Imap")
install.packages("gbm")
install.packages("darksky")
install.packages("purrr")
install.packages("RJSONIO")

library(gbm)
library(jsonlite)
library(dplyr)
library(lubridate)
library(Imap)
library(bestglm)
library(glmnet)
library(randomForest)
library(e1071)
library(kernlab)
library(jsonlite)
library(RCurl)
library(curl)
library(darksky)
library(purrr)
library(RJSONIO)
library(plyr)

#importation des données météo

#url <- 'https://api.darksky.net/forecast/9778cdc6ddc2eaf7b6854ad412c21eec/48.866667,2.333333'
#now <- get_current_forecast(48.866667, 2.333333)

#darksky_api_key <- "9778cdc6ddc2eaf7b6854ad412c21eec"

#tmp <- get_forecast_for(48.866667,2.333333,"2016-08-01T12:00:00",units="si",language = "fr")
#tmp1<-as.data.frame(tmp)


#lancer 1 prremiere fois. demande de clé dans console. rentrer clé et relancer

#########
date.range <- seq.Date(from=as.Date('2016-12-01'), to=as.Date('2017-02-28'), by='1 day')
date.range


hdwd <- data.frame()

for(i in seq_along(date.range)) {
  tmp<-get_forecast_for(48.866667,2.333333,paste(date.range[i],'T12:00:00',sep=""),units="si",language = "fr")
  tmp1<-as.data.frame(tmp)
  tmp2<-data.frame(tmp1$hourly.time,tmp1$hourly.summary,tmp1$hourly.precipIntensity,tmp1$hourly.temperature)
  hdwd <- rbind(hdwd,tmp2)
}

hdwd$date <- as.POSIXct(hdwd$tmp1.hourly.time, origin="1970-01-01")
hdwd$jour<- weekdays(as.Date(hdwd$date))
hdwd$mois<- months(as.Date(hdwd$date))
hdwd$annee<- format(hdwd$date,"%Y")
hdwd$jour_num<-as.POSIXlt(hdwd$date)$mday
hdwd$heure <- as.numeric(format(hdwd$date, "%H"))

meteo<-hdwd

names(meteo)[2]<-"ciel"
names(meteo)[3]<-"precipitation"
names(meteo)[4]<-"temperature"

#rm(hdwd,tmp1,tmp2,tmp,serie)



setwd("//telemaque/users/CEPE-S1-02/Bureau")
#setwd("C:/Users/sevdr/Desktop/data scientist/Projet velib")

vacance<-read.table("vacance.csv",sep=";",header=T)

velib2<-read.csv("stations-velib-disponibilites-en-temps-reel.csv",
                 sep=";")
names(velib2)
hist(velib2$bike_stands,freq=FALSE,xlab="Taille",main="Hist. de la taille des stations")
lines(density(velib2$bike_stands),lwd=2,col=2)
position <- as.character(velib2$position)
vecteur <- do.call('rbind',strsplit(position,',',fixed=TRUE))
velib2$longitude <- as.numeric(vecteur[,2])
velib2$latitude <- as.numeric(vecteur[,1])
summary(velib2)
rm(data.range,i,position)
?readLines
# le document initial est compos? de plusieurs doc JSON

# on applique le fonction FROMJSON a chaque doc JSON, pour les transformer en DataFrame

#Histo_velib <- readLines(file("C:/Users/sevdr/Desktop/data scientist/data_all_Paris.jjson.txt"))

Histo_velib<- readLines(file("//telemaque/users/CEPE-S1-02/Bureau/data_all_Paris.jjson"))

Histo_velib <- lapply(Histo_velib,jsonlite::fromJSON)

# pour obtenir un dataFrame de toutes les dataFrame
HistoDT <- do.call('rbind',Histo_velib)

#creation d'une table unique 
#format date pour l'année 

HistoDT$date <- as.POSIXct(HistoDT$download_date, origin="1970-01-01")
HistoDT$jour<- weekdays(as.Date(HistoDT$date))
HistoDT$mois<- as.factor(months(as.Date(HistoDT$date)))
HistoDT$annee<- format(HistoDT$date,"%Y")
HistoDT$jour_num<-as.POSIXlt(HistoDT$date)$mday
HistoDT$mois_num<-as.POSIXlt(HistoDT$date)$m

HistoDT$heure <- as.numeric(format(HistoDT$date, "%H"))
HistoDT$minute <- as.numeric(format(HistoDT$date, "%M"))

HistoDT$heure_minute <- paste(HistoDT$heure,HistoDT$minute ,sep="_")

location_dispo<-HistoDT[,c("date","number","available_bikes",
                           "annee","mois","heure",
                           "jour_num","jour","heure_minute","minute","download_date")]

location_dispo<-location_dispo[order(location_dispo$number,location_dispo$date),]
#variable retard

#calcul des stations les plus proches  (distance entre les stations)
ReplaceLowerOrUpperTriangle <- function(m, triangle.to.replace){
  # If triangle.to.replace="lower", replaces the lower triangle of a square matrix with its upper triangle.
  # If triangle.to.replace="upper", replaces the upper triangle of a square matrix with its lower triangle.
  
  if (nrow(m) != ncol(m)) stop("Supplied matrix must be square.")
  if      (tolower(triangle.to.replace) == "lower") tri <- lower.tri(m)
  else if (tolower(triangle.to.replace) == "upper") tri <- upper.tri(m)
  else stop("triangle.to.replace must be set to 'lower' or 'upper'.")
  m[tri] <- t(m)[tri]
  return(m)
}

GeoDistanceInMetresMatrix <- function(df.geopoints){
  # Returns a matrix (M) of distances between geographic points.
  # M[i,j] = M[j,i] = Distance between (df.geopoints$lat[i], df.geopoints$lon[i]) and
  # (df.geopoints$lat[j], df.geopoints$lon[j]).
  # The row and column names are given by df.geopoints$name.
  
  GeoDistanceInMetres <- function(g1, g2){
    # Returns a vector of distances. (But if g1$index > g2$index, returns zero.)
    # The 1st value in the returned vector is the distance between g1[[1]] and g2[[1]].
    # The 2nd value in the returned vector is the distance between g1[[2]] and g2[[2]]. Etc.
    # Each g1[[x]] or g2[[x]] must be a list with named elements "index", "lat" and "lon".
    # E.g. g1 <- list(list("index"=1, "lat"=12.1, "lon"=10.1), list("index"=3, "lat"=12.1, "lon"=13.2))
    DistM <- function(g1, g2){
      require("Imap")
      return(ifelse(g1$index > g2$index, 0, gdist(lat.1=g1$lat, lon.1=g1$lon, lat.2=g2$lat, lon.2=g2$lon, units="m")))
    }
    return(mapply(DistM, g1, g2))
  }
  
  n.geopoints <- nrow(df.geopoints)
  
  # The index column is used to ensure we only do calculations for the upper triangle of points
  df.geopoints$index <- 1:n.geopoints
  
  # Create a list of lists
  list.geopoints <- by(df.geopoints[,c("index", "lat", "lon")], 1:n.geopoints, function(x){return(list(x))})
  
  # Get a matrix of distances (in metres)
  mat.distances <- ReplaceLowerOrUpperTriangle(outer(list.geopoints, list.geopoints, GeoDistanceInMetres), "lower")
  
  # Set the row and column names
  rownames(mat.distances) <- df.geopoints$name
  colnames(mat.distances) <- df.geopoints$name
  
  return(mat.distances)
}


############################################################################################################################
#introduction des données météo

location_dispo$fusion<-paste(location_dispo$annee,
                             location_dispo$mois,
                             location_dispo$heure,
                             location_dispo$jour_num,
                             sep='')

meteo$fusion<-paste(meteo$annee,
                    meteo$mois,
                    meteo$heure,
                    meteo$jour_num,
                    sep='')


locat_dispo<-left_join(location_dispo, 
                       meteo[,c("ciel","precipitation",
                                "temperature","fusion")], 
                       by ="fusion")
locat_dispo$we<- "WE" 
locat_dispo$we[locat_dispo$jour%in% c("lundi","mardi","mercredi","jeudi","vendredi")] <- "Semaine" 


loc_dispo<-locat_dispo[,c("number","available_bikes",
                          "jour","heure","minute","temperature","precipitation")]

loc_dispo$jour<-as.factor(loc_dispo$jour)
#loc_dispo$we<-as.factor(loc_dispo$we)

list_station <-c(unique(loc_dispo[,"number"]))

list_station <-c(unique(loc_dispo[,"number"]))

resultat <- list(rf)        


for(i in 1 : length(list_station))
{
  station < - as.character(list_station[i])
  dispo<-loc_dispo[which(loc_dispo$number==list_station[i]),]
  dispo$number<-NULL
  
  n<-nrow(dispo)
  indextrain<-sample(1:n,size=n/2) 
  
  rf <- randomForest(available_bikes~.,data=dispo[indextrain,],ntree=50)
  varImpPlot(rf)
  rf$importance[order(rf$importance[,1],decreasing=T),]
  resultat[[station]] <-rf
  print(i)
  
}

resultat_heure_minute<-resultat
saveRDS(resultat_heure_minute,file="resultat.RDS")

#
tt<-readRDS(file="//telemaque/users/CEPE-S1-02/Bureau/resultat.RDS") #global dans shiny

